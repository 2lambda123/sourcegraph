package embed

import (
	"context"
	"path/filepath"
	"strings"
	"unicode/utf8"

	"github.com/sourcegraph/sourcegraph/enterprise/internal/embeddings"
	"github.com/sourcegraph/sourcegraph/enterprise/internal/embeddings/split"
	"github.com/sourcegraph/sourcegraph/internal/api"
)

const MAX_CODE_EMBEDDING_VECTORS = 768_000
const MAX_TEXT_EMBEDDING_VECTORS = 128_000

const MAX_LINE_LENGTH = 2048

const EMBED_ENTIRE_FILE_TOKENS_THRESHOLD = 768
const EMBEDDING_CHUNK_TOKENS_THRESHOLD = 512
const EMBEDDING_CHUNK_EARLY_SPLIT_TOKENS_THRESHOLD = EMBEDDING_CHUNK_TOKENS_THRESHOLD - 64

const COLUMN_DIMENSION = 1024 // TODO: Read from config

type readFile func(fileName string) ([]byte, error)

var autogeneratedFileHeaders = []string{"autogenerated file", "lockfile", "generated by", "do not edit"}

var textFileExtensions = map[string]struct{}{
	"md":       {},
	"markdown": {},
	"rst":      {},
	"txt":      {},
}

var ignoreCodeFileExtensions = map[string]struct{}{
	"sql":  {},
	"svg":  {},
	"json": {},
	"yml":  {},
	"yaml": {},
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func isEmbeddableFile(content string) bool {
	lines := strings.Split(content, "\n")

	fileHeader := strings.ToLower(strings.Join(lines[0:min(5, len(lines))], "\n"))
	for _, header := range autogeneratedFileHeaders {
		if strings.Contains(fileHeader, header) {
			return false
		}
	}

	for _, line := range lines {
		if len(line) > MAX_LINE_LENGTH {
			return false
		}
	}

	return true
}

func isTextFile(fileName string) bool {
	ext := filepath.Ext(fileName)
	if len(ext) == 0 {
		return true
	}
	_, ok := textFileExtensions[strings.ToLower(ext)]
	return ok
}

func isValidCodeFile(fileName string) bool {
	ext := filepath.Ext(fileName)
	_, ok := ignoreCodeFileExtensions[strings.ToLower(ext)]
	return !ok
}

func EmbedRepo(ctx context.Context, repoName api.RepoName, revision api.CommitID, fileNames []string, readFile readFile) (*embeddings.RepoEmbeddingIndex, error) {
	codeFileNames, textFileNames := []string{}, []string{}
	for _, fileName := range fileNames {
		if isTextFile(fileName) {
			textFileNames = append(textFileNames, fileName)
		} else if isValidCodeFile(fileName) {
			codeFileNames = append(codeFileNames, fileName)
		}
	}

	codeIndex, err := embedFiles(ctx, codeFileNames, readFile, MAX_CODE_EMBEDDING_VECTORS)
	if err != nil {
		return nil, err
	}

	textIndex, err := embedFiles(ctx, textFileNames, readFile, MAX_TEXT_EMBEDDING_VECTORS)
	if err != nil {
		return nil, err
	}

	return &embeddings.RepoEmbeddingIndex{
		RepoName:  repoName,
		Revision:  revision,
		CodeIndex: codeIndex,
		TextIndex: textIndex,
	}, nil
}

func embedFiles(ctx context.Context, fileNames []string, readFile readFile, maxEmbeddingVectors int) (*embeddings.EmbeddingIndex[embeddings.RepoEmbeddingRowMetadata], error) {
	if len(fileNames) == 0 {
		return nil, nil
	}

	fileEmbeddings := make([]float32, 0, len(fileNames)*COLUMN_DIMENSION)
	rowMetadata := make([]embeddings.RepoEmbeddingRowMetadata, 0, len(fileNames))

	splitOptions := split.SplitOptions{
		ChunkTokensThreshold:           EMBEDDING_CHUNK_TOKENS_THRESHOLD,
		ChunkEarlySplitTokensThreshold: EMBEDDING_CHUNK_EARLY_SPLIT_TOKENS_THRESHOLD,
	}
	for _, fileName := range fileNames {
		contentBytes, err := readFile(fileName)
		if err != nil {
			return nil, err
		}
		if !utf8.Valid(contentBytes) {
			continue
		}
		content := string(contentBytes)
		if !isEmbeddableFile(content) {
			continue
		}

		chunks, metadata := []string{}, []embeddings.RepoEmbeddingRowMetadata{}
		if embeddings.CountTokens(content) < EMBED_ENTIRE_FILE_TOKENS_THRESHOLD {
			chunks = append(chunks, content)
			metadata = append(metadata, embeddings.RepoEmbeddingRowMetadata{
				FileName:  fileName,
				StartLine: 0,
				EndLine:   strings.Count(content, "\n") + 1,
			})
		} else {
			chunks, metadata = split.SplitIntoEmbeddableChunks(content, fileName, splitOptions)
		}

		if len(rowMetadata)+len(metadata) > maxEmbeddingVectors {
			break
		}

		rowMetadata = append(rowMetadata, metadata...)

		// TODO: We don't call embeddings one by one, but group them
		for _, chunk := range chunks {
			embedding, err := getEmbedding(ctx, chunk)
			if err != nil {
				return nil, err
			}
			fileEmbeddings = append(fileEmbeddings, embedding...)
		}
	}

	return &embeddings.EmbeddingIndex[embeddings.RepoEmbeddingRowMetadata]{
		Embeddings:      fileEmbeddings,
		ColumnDimension: COLUMN_DIMENSION,
		RowMetadata:     rowMetadata,
	}, nil
}

func getEmbedding(ctx context.Context, chunk string) ([]float32, error) {
	embeddings := make([]float32, COLUMN_DIMENSION)
	// for i := 0; i < COLUMN_DIMENSION; i++ {
	// 	embeddings[i] = rand.Float32()
	// }
	return embeddings, nil
}
