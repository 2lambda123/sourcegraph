import { OpenAIEmbeddings } from 'langchain/embeddings/openai'
import { MarkdownTextSplitter } from 'langchain/text_splitter'
import { HNSWLib } from 'langchain/vectorstores/hnswlib'
import { Octokit } from 'octokit'

import { ENVIRONMENT_CONFIG, DEFAULT_CODEBASES, AppContext } from './constants'
import { handleHumanMessage } from './mention-handler'
import { createCodebaseContext } from './services/codebase-context'
import { isBotEvent } from './slack/helpers'
import { app } from './slack/init'

const { PORT } = ENVIRONMENT_CONFIG

const octokit = new Octokit({ auth: ENVIRONMENT_CONFIG.GITHUB_TOKEN })

interface FetchFileContentOptions {
    owner: string
    repo: string
    path: string
}

async function fetchFileContent(options: FetchFileContentOptions) {
    const { owner, repo, path } = options

    try {
        const response = await octokit.rest.repos.getContent({ owner, repo, path })
        if ('type' in response.data && response.data.type === 'file') {
            const content = Buffer.from(response.data.content, 'base64').toString('utf8')
            return {
                content,
                url: response.data.html_url,
            }
        } else {
            console.error('Unexpected response fetching file from GitHub:', response)
        }
    } catch (error) {
        console.error('Error fetching file from GitHub!', error)
    }

    return undefined
}

async function getDocuments() {
    const codyNotice = await fetchFileContent({
        owner: 'sourcegraph',
        repo: 'about',
        path: 'content/terms/cody-notice.md',
    })

    if (!codyNotice) {
        return []
    }

    const { content, url } = codyNotice
    const splitter = new MarkdownTextSplitter()
    const documents = await splitter.createDocuments([content])

    documents.map((document, index) => {
        document.metadata = {
            fileName: url,
            hnswLabel: index,
        }

        return document
    })

    return documents
}

const VECTOR_UPDATE_TIMEOUT = 12 * 60 * 60 * 1000

function scheduleVectorUpdate(vectorStore: HNSWLib, timeout: number) {
    setTimeout(async () => {
        try {
            vectorStore._index = undefined
            vectorStore.docstore._docs.clear()

            const documents = await getDocuments()
            await vectorStore.addDocuments(documents)
        } catch (error) {
            console.error('Failed to update vectors', error)
        } finally {
            scheduleVectorUpdate(vectorStore, timeout)
        }
    }, timeout)
}

export async function getVectorStore() {
    const documents = await getDocuments()

    const embeddings = new OpenAIEmbeddings()
    const vectorStore = await HNSWLib.fromDocuments(documents, embeddings)

    scheduleVectorUpdate(vectorStore, VECTOR_UPDATE_TIMEOUT)

    return vectorStore
}

// Main function to start the bot
async function startBot() {
    // Init codebase context clients for specified Slack channels.
    const appContext = { codebaseContexts: {} } as AppContext
    for (const codebase of DEFAULT_CODEBASES) {
        appContext.codebaseContexts[codebase] = await createCodebaseContext(codebase)
    }
    appContext.vectorStore = await getVectorStore()

    // Listen for mentions in the Slack app
    app.event<'app_mention'>('app_mention', async ({ event }) => {
        // Ignore events generated by bots
        if (isBotEvent(event)) {
            return
        }

        console.log('APP_MENTION:', event.text)
        // Process the mention event generated by a human user
        await handleHumanMessage(event, appContext)
    })

    // Start the Slack app on the specified port
    return app.start(PORT)
}

// Start the bot and log the status
startBot()
    .then(() => console.log(`⚡️ Cody Slack-bot is running on port ${PORT}!`))
    .catch(error => {
        console.error('Error starting the bot:', error)
        process.exit(1)
    })
